#include "hip/hip_runtime.h"
#include <iostream>
#include "gpukernel.h"
#include "mpi.h"
#include <math.h>
#define BLOCKSIZE 256 

GParam *gparamlist;
CParam *cparamlist;
int Initflag;
int nowblock;
int myrank;
#define groupsize 4

__global__ void GPU_HelloWorld(int* a){
	int i;
	i = hipBlockDim_x * hipBlockIdx_x + hipThreadIdx_x;
	a[i] = i;
}

void InitDeviceMemory(GParam* param,int numOwnedPoints, int neighborsize, double*x ,double* weightvolume, double* cellvolume, int* bonddamage, int* neighborhoodlist, int* neighborPtr,int globalnum){
	int i;
	hipMalloc((void**)&(param->x),globalnum*sizeof(double));
	hipMalloc((void**)&(param->y),globalnum*sizeof(double));
	hipMalloc((void**)&(param->force),globalnum*sizeof(double));
	hipMalloc((void**)&(param->weightvolume),globalnum/3*sizeof(double));
	hipMalloc((void**)&(param->cellvolume),globalnum/3*sizeof(double));
	hipMalloc((void**)&(param->dilatation),globalnum/3*sizeof(double));
	hipMalloc((void**)&(param->neighborPtr),numOwnedPoints*sizeof(int));
	hipMalloc((void**)&(param->mybondDamage),neighborsize*sizeof(int));
	hipMalloc((void**)&(param->neiborlist),neighborsize*sizeof(int));
	hipMemcpy(param->x, x, globalnum*sizeof(double),hipMemcpyHostToDevice);
	hipMemcpy(param->cellvolume, cellvolume, globalnum/3*sizeof(double),hipMemcpyHostToDevice);
	hipMemcpy(param->weightvolume, weightvolume, globalnum/3*sizeof(double),hipMemcpyHostToDevice);
	hipMemcpy(param->mybondDamage, bonddamage, (neighborsize-numOwnedPoints/4)*sizeof(int),hipMemcpyHostToDevice);
	hipMemcpy(param->neiborlist, neighborhoodlist, neighborsize*sizeof(int),hipMemcpyHostToDevice);
	hipMemcpy(param->neighborPtr, neighborPtr, numOwnedPoints/4*sizeof(int),hipMemcpyHostToDevice);
	int deviceID = myrank % 4;
        hipGetDevice(&deviceID);
	printf("Initial Memory on Device %p %p %d\n",param, param->force,deviceID);
	/*int st = neighborPtr[35249];
	for(int i=0; i< neighborhoodlist[st];i++)
		printf("%d ",neighborhoodlist[st+1+i]);
	printf("\n");*/
	
}

void CPU_HelloWorld(int *a){
	int i;
	int *deva;
	//hipMalloc((void **)&deva, 1024*sizeof(int));
	//printf("~~~~CPU HELLOWOLRD!!!\n");
	for(i=0;i<1024;i++)
		a[i] = 0;
	/*hipMemcpy(deva, a, 1024*sizeof(int), hipMemcpyHostToDevice);
	hipLaunchKernelGGL(GPU_HelloWorld, dim3(8),dim3(128),0,0,deva);
	hipMemcpy(a, deva, 1024*sizeof(int), hipMemcpyDeviceToHost);
	if(a[128]==128)
		printf("~~~GPU is started successfully!!!!!\n");*/
}

__global__ void DilatationKernel(double *x, double *y, double*m, double* c, double *d, int* bonddamage, int * neighborlist, int numOwnedpoints, double horizon, int* neighborPtr){
	int i,j,k;
	i = hipBlockDim_x * hipBlockIdx_x + hipThreadIdx_x;
	if(i< numOwnedpoints){
		int *Nptr = &neighborlist[neighborPtr[i/groupsize]];
		int *bond = &bonddamage[neighborPtr[i/groupsize]-i/groupsize]; 
		int numNeigh = *Nptr;
		Nptr++;
		double ixx =x[i*3];	
		double ixy =x[i*3+1];	
		double ixz =x[i*3+2];	
		double iyx =y[i*3];	
		double iyy =y[i*3+1];	
		double iyz =y[i*3+2];
		double di = 0;
		double xdx,xdy,xdz,initdist,ydx,ydy,ydz,currdist,e;
		double s;
		int ci = i/groupsize;
		int position =  i % groupsize;
		int loop = numNeigh/groupsize /*+ (numNeigh%groupsize != 0)*/;
		double rx[4],ry[4];
		int rc[4];
		int stid = (i/groupsize)*groupsize;
		int damage;
		for(j=0;j<loop;j++){
			int p = Nptr[j*groupsize + position];
			rx[0] = x[p*3];
			rx[1] = x[p*3+1];
			rx[2] = x[p*3+2];
			rx[3] = c[p]; 
			ry[0] = y[p*3];
			ry[1] = y[p*3+1];
			ry[2] = y[p*3+2];
			ry[3] = m[p];
			for(k=0;k<groupsize;k++){
				//int thisp = __shlf(p, stid+(position+k)%groupsize);
				damage = (bond[j*groupsize+k]>>position)&0x00000001;
				double xjx = __shfl(rx[0], stid+(position+k)%groupsize, 64);
				double xjy = __shfl(rx[1], stid+(position+k)%groupsize, 64);
				double xjz = __shfl(rx[2], stid+(position+k)%groupsize, 64);
				double cj = __shfl(rx[3], stid+(position+k)%groupsize, 64);
				double yjx = __shfl(ry[0], stid+(position+k)%groupsize, 64);
				double yjy = __shfl(ry[1], stid+(position+k)%groupsize, 64);
				double yjz = __shfl(ry[2], stid+(position+k)%groupsize, 64);
				double mj = __shfl(ry[3], stid+(position+k)%groupsize, 64);
				xdx = ixx - xjx;
				xdy = ixy - xjy;
				xdz = ixz - xjz;
                        	initdist = sqrt(xdx*xdx + xdy*xdy + xdz*xdz);
				int flag = (initdist<=horizon);
				ydx = yjx - iyx;
				ydy = yjy - iyy;
				ydz = yjz - iyz;
                        	currdist = sqrt(ydx*ydx + ydy*ydy + ydz*ydz);
                        	e = currdist - initdist;
				s = e/initdist;
				int bflag = (s>0.02);
				damage = bflag | damage;
				di += flag*3*(1-damage)*initdist*e*cj/m[i];
				rc[k] = damage<<position;
				//atomicOr(&bond[j*groupsize+k],damage<<position);
				
			}
			int dam = 0;
			dam |= rc[position];
			for(k=1;k<groupsize;k++){
				dam |= __shfl(rc[stid+(position+k)%groupsize], stid+(position-k)%groupsize, 64);
			}
			bond[j*groupsize+position] = dam;
			
		
		}
		//rest = numNeigh % groupsize;
		for(int n = j*groupsize; n<numNeigh; n++){
			int p = Nptr[n];
			xdx = ixx - x[p*3];	
			xdy = ixy - x[p*3+1];	
			xdz = ixz - x[p*3+2];
			int damage = (bond[n] >> position)&0x00000001;
			//int damage = 0;
                        initdist = sqrt(xdx*xdx + xdy*xdy + xdz*xdz);
			int flag = (initdist<=horizon);
                        ydx = y[p*3] - iyx;
                        ydy = y[p*3+1] - iyy;
                        ydz = y[p*3+2] - iyz;
                        currdist = sqrt(ydx*ydx + ydy*ydy + ydz*ydz);
                        e = currdist - initdist;
			s = e/initdist;
			int bflag = (s>0.02);
			damage = bflag | damage;
			//if(s > 0.02)
			//	*bond = 1.0;
			di += flag*3*(1-damage)*initdist*e*c[p]/m[i];
			atomicOr(&bond[n],damage<<position);
		}
	     d[i] = di;	
		
	}
}
__global__ void ForceKernel(double *x, double *y, double*m, double* c, double *d, int* bonddamage, double *f, int * neighborlist, int numOwnedpoints,double bulkModulus,double shearModulus, double horizon, int* neighborPtr){
	int i,j,k;
	i = hipBlockDim_x * hipBlockIdx_x + hipThreadIdx_x;
	if(i< numOwnedpoints){
		int *Nptr = &neighborlist[neighborPtr[i/groupsize]];
		int *bond = &bonddamage[neighborPtr[i/groupsize]-i/groupsize]; 
		int numNeigh = *Nptr;
		Nptr++;
		double K = bulkModulus;
		double MU = shearModulus;
		double ixx =x[i*3];	
		double ixy =x[i*3+1];	
		double ixz =x[i*3+2];	
		double iyx =y[i*3];	
		double iyy =y[i*3+1];	
		double iyz =y[i*3+2];
		double fxi = 0;
		double fyi = 0;
		double fzi = 0;
		double xdx,xdy,xdz,initdist,ydx,ydy,ydz,currdist,e;
		int position =  i % groupsize;
		int ci = i/groupsize;
		//int position =  i % groupsize;
		int loop = numNeigh/groupsize /*+ (numNeigh%groupsize != 0)*/;
		double rx[4],ry[4],rd;
		int rc[4];
		int stid = (i/groupsize)*groupsize;
		int damage;
		/*for(j=0;j<loop;j++){
			int p = Nptr[j*groupsize + position];
			rx[0] = x[p*3];
			rx[1] = x[p*3+1];
			rx[2] = x[p*3+2];
			rx[3] = c[p]; 
			ry[0] = y[p*3];
			ry[1] = y[p*3+1];
			ry[2] = y[p*3+2];
			ry[3] = m[p];
			rd = d[p];
			for(k=0;k<groupsize;k++){
				damage = (bond[j*groupsize+k]>>position)&0x00000001;
				double xjx = __shfl(rx[0], stid+(position+k)%groupsize, 64);
				double xjy = __shfl(rx[1], stid+(position+k)%groupsize, 64);
				double xjz = __shfl(rx[2], stid+(position+k)%groupsize, 64);
				double cj = __shfl(rx[3], stid+(position+k)%groupsize, 64);
				double yjx = __shfl(ry[0], stid+(position+k)%groupsize, 64);
				double yjy = __shfl(ry[1], stid+(position+k)%groupsize, 64);
				double yjz = __shfl(ry[2], stid+(position+k)%groupsize, 64);
				double mj = __shfl(ry[3], stid+(position+k)%groupsize, 64);
				double dj = __shfl(rd, stid+(position+k)%groupsize, 64);
				xdx = ixx - xjx;
				xdy = ixy - xjy;
				xdz = ixz - xjz;
                        	initdist = sqrt(xdx*xdx + xdy*xdy + xdz*xdz);
				int flag = (initdist<=horizon);
                        	ydx = yjx - iyx;
                        	ydy = yjy - iyy;
                        	ydz = yjz - iyz;
                        	currdist = sqrt(ydx*ydx + ydy*ydy + ydz*ydz);
                        	e = currdist - initdist;
                        	double zeroflag = (double)(currdist == 0);
                        	double alpha = 15.0*MU/m[i];
                        	double alphap = 15.0*MU/mj;
                        	double c1 = 1 * d[i] * (3.0*K/m[i] - alpha/3.0);
                        	double cp = 1 * dj * (3.0*K/mj - alphap/3.0);
                        	double t = (1-damage) * (c1* initdist + (1-damage)*1*alpha*e)*flag;
                        	double tp = (1-damage) * (cp* initdist + (1-damage)*1*alphap*e)*flag;
                        	double fx = t * ydx/(currdist+zeroflag);
                        	double fy = t * ydy/(currdist+zeroflag);
                        	double fz = t * ydz/(currdist+zeroflag);
                        	double fxp = tp * ydx/(currdist+zeroflag);
                        	double fyp = tp * ydy/(currdist+zeroflag);
                        	double fzp = tp * ydz/(currdist+zeroflag);
                        	fxi += fx *cj;
                        	fyi += fy *cj;
                        	fzi += fz *cj;
                        	fxi += fxp *cj;
                        	fyi += fyp *cj;
                        	fzi += fzp *cj;
			}
		}*/
		for(int n = 0; n<numNeigh; n++){
			int p = Nptr[n];
                        xdx = ixx - x[p*3];
                        xdy = ixy  - x[p*3+1];
                        xdz = ixz - x[p*3+2];
                        initdist = sqrt(xdx*xdx + xdy*xdy + xdz*xdz);
			damage = (bond[n] >> position)&0x00000001;
			int flag = (initdist<=horizon);
                        //flag = (double)(initdist  <= horizon);
                        ydx = y[p*3] - iyx;
                        ydy = y[p*3+1] - iyy;
                        ydz = y[p*3+2] - iyz;
                        currdist = sqrt(ydx*ydx + ydy*ydy + ydz*ydz);
                        e = currdist - initdist;
                        double zeroflag = (double)(currdist == 0);
                      	//zeroflag = 1.0e-16;
                        double alpha = 15.0*MU/m[i];
                        double alphap = 15.0*MU/m[p];
                        double c1 = 1 * d[i] * (3.0*K/m[i] - alpha/3.0);
                        double cp = 1 * d[p] * (3.0*K/m[p] - alphap/3.0);
                        double t = (1-damage) * (c1* initdist + (1-damage)*1*alpha*e)*flag;
                        double tp = (1-damage) * (cp* initdist + (1-damage)*1*alphap*e)*flag;
                        double fx = t * ydx/(currdist+zeroflag);
                        double fy = t * ydy/(currdist+zeroflag);
                        double fz = t * ydz/(currdist+zeroflag);
                        double fxp = tp * ydx/(currdist+zeroflag);
                        double fyp = tp * ydy/(currdist+zeroflag);
                        double fzp = tp * ydz/(currdist+zeroflag);
                        fxi += fx *c[p];
                        fyi += fy *c[p];
                        fzi += fz *c[p];
                        fxi += fxp *c[p];
                        fyi += fyp *c[p];
                        fzi += fzp *c[p];
		}
		f[i*3] = fxi;
		f[i*3+1] = fyi;
		f[i*3+2] = fzi;
	}
	
}

void ForceTest(double *x, double *y, double*m, double* c, double *d, double* bonddamage, double *f, const int * neighborlist, int numOwnedpoints,double bulkModulus,double shearModulus, double horizon, int* neighborPtr){
	int i = 0;
	//i = hipBlockDim_x * hipBlockIdx_x + hipThreadIdx_x;
	if(i< numOwnedpoints){
		const int *Nptr = &neighborlist[neighborPtr[i]];
		double *bond = &bonddamage[neighborPtr[i]-i]; 
		int numNeigh = *Nptr;
		Nptr++;
		double K = bulkModulus;
		double MU = shearModulus;
		double ixx =x[i*3];	
		double ixy =x[i*3+1];	
		double ixz =x[i*3+2];	
		double iyx =y[i*3];	
		double iyy =y[i*3+1];	
		double iyz =y[i*3+2];
		double fxi = 0;
		double fyi = 0;
		double fzi = 0;
		double xdx,xdy,xdz,initdist,ydx,ydy,ydz,currdist,e;
		for(int n =0; n<numNeigh; n++,Nptr++, bond++){
			int p = *Nptr;
                        xdx = ixx - x[p*3];
                        xdy = ixy  - x[p*3+1];
                        xdz = ixz - x[p*3+2];
                        initdist = sqrt(xdx*xdx + xdy*xdy + xdz*xdz);
                        //flag = (double)(initdist  <= horizon);
                        ydx = y[p*3] - iyx;
                        ydy = y[p*3+1] - iyy;
                        ydz = y[p*3+2] - iyz;
                        currdist = sqrt(ydx*ydx + ydy*ydy + ydz*ydz);
                        e = currdist - initdist;
                        double zeroflag = (double)(currdist == 0);
                      	//zeroflag = 1.0e-16;
                        double alpha = 15.0*MU/m[i];
                        double alphap = 15.0*MU/m[p];
                        double c1 = 1 * d[i] * (3.0*K/m[i] - alpha/3.0);
                        double cp = 1 * d[p] * (3.0*K/m[p] - alphap/3.0);
                        double t = (1-*bond) * (c1* initdist + (1-*bond)*1*alpha*e);
                        double tp = (1-*bond) * (cp* initdist + (1-*bond)*1*alphap*e);
                        double fx = t * ydx/(currdist+zeroflag);
                        double fy = t * ydy/(currdist+zeroflag);
                        double fz = t * ydz/(currdist+zeroflag);
                        double fxp = tp * ydx/(currdist+zeroflag);
                        double fyp = tp * ydy/(currdist+zeroflag);
                        double fzp = tp * ydz/(currdist+zeroflag);
			//if(myrank == 1)
			//	printf("%d MyForce:%e\n",p, fxp*c[p]);
                        fxi += fx *c[p];
                        fyi += fy *c[p];
                        fzi += fz *c[p];
                        fxi += fxp *c[p];
                        fyi += fyp *c[p];
                        fzi += fzp *c[p];
		}
		f[i*3] = fxi;
		f[i*3+1] = fyi;
		f[i*3+2] = fzi;
	}
	
}

void GPU_Dilatation_Interface(double *x, double *y, double *weightvolume, double* cellvolume,double *dilatation, double* bondDamage, const int* neighborhoodList, int numOwnedPoints, double horizon, double m_alpha, double* deltaTemperature, GParam* param ){
	//int i;
	int i;
	int nthreads = numOwnedPoints;
	int nblocks = numOwnedPoints/BLOCKSIZE+1;
	int globalnum = param->numOwnedpoints;
	hipMemcpy(param->y,y,globalnum*sizeof(double),hipMemcpyHostToDevice);
	//hipMemcpy(param->bonddamage, param->mybondDamage, (param->neighborsize-numOwnedPoints/groupsize)*sizeof(double),hipMemcpyHostToDevice);
	hipLaunchKernelGGL(DilatationKernel, dim3(nblocks),dim3(BLOCKSIZE),0,0,param->x, param->y, param->weightvolume, param->cellvolume, param->dilatation, param->mybondDamage, param->neiborlist, numOwnedPoints, horizon, param->neighborPtr);
	hipDeviceSynchronize();
	//hipMemcpy( param->mybondDamage, param->bonddamage, (param->neighborsize-numOwnedPoints/groupsize)*sizeof(double),hipMemcpyDeviceToHost);
	hipMemcpy(dilatation, param->dilatation, numOwnedPoints*sizeof(double),hipMemcpyDeviceToHost);
}


void GPU_Force_Interface(double *x, double *y, double* weightvolume, double* cellvolume, double* dilatation, double* bondDamage, double* force, double* partialStress, const int* neighborhoodList, int numOwnedPoints, double bulkModulus, double shearModulus, double horizon, double alpha, double* deltaTemperature, GParam* param, double* oriforce ){
	int i;
	int nthreads = numOwnedPoints;
	int nblocks = numOwnedPoints/BLOCKSIZE+1;
	int globalnum = param->numOwnedpoints;
  	int mpi_size;
	MPI_Status* mpistat;
	MPI_Request* mpireq;
  	MPI_Comm_size(MPI_COMM_WORLD, &mpi_size);
  	mpistat = (MPI_Status *)malloc(sizeof(MPI_Status)*mpi_size*2);
  	mpireq = (MPI_Request *)malloc(sizeof(MPI_Request)*mpi_size*4);
	hipMemcpy(param->y,y,globalnum*sizeof(double),hipMemcpyHostToDevice);
	hipMemcpy(param->dilatation,dilatation,globalnum/3*sizeof(double),hipMemcpyHostToDevice);
	//hipMemcpy(param->bonddamage, bondDamage, (param->neighborsize-numOwnedPoints)*sizeof(double),hipMemcpyHostToDevice);
	param->bulkModulus = bulkModulus;
	param->shearModulus = shearModulus;
	param->horizon = horizon;
	double ***sendbuf = param->sendbuf;
	double ***recvbuf = param->recvbuf;
	int **NumImport = param->NumImport;
	int **NumProcRequest = param->NumProcRequest;
	int ***ProcRequestList = param->ProcRequestList;
	int ***ProcExportList = param->ProcExportList;
	int **LIDList = param->LIDList;
	int MaxGID = param->MaxGID;
	int MinGID = param->MinGID;
	for(i=0;i<mpi_size;i++){
		if(i!=myrank && NumProcRequest[nowblock][i]){
			for(int j=0;j<NumProcRequest[nowblock][i];j++){
				int nid = ProcExportList[nowblock][i][j];
				int lid = LIDList[nowblock][nid-MinGID];
				sendbuf[nowblock][i][j] = dilatation[lid];
			}
			MPI_Isend(sendbuf[nowblock][i], NumProcRequest[nowblock][i], MPI_DOUBLE, i, myrank*10+i, MPI_COMM_WORLD, &mpireq[i*2] );
			MPI_Irecv(recvbuf[nowblock][i], NumImport[nowblock][i], MPI_DOUBLE, i, i*10+myrank, MPI_COMM_WORLD, &mpireq[i*2+1]);
			
		}
	}
	for(i=0;i<mpi_size;i++){
		if(i!=myrank && NumProcRequest[nowblock][i]!=0){
                        MPI_Wait(&mpireq[i*2],&mpistat[i*2]);
                        MPI_Wait(&mpireq[i*2+1],&mpistat[i*2+1]);
		}
	}
	for(i=0;i<mpi_size;i++){
		for(int j=0;j<NumImport[nowblock][i];j++){
			int nid = ProcRequestList[nowblock][i][j];	
			int lid = LIDList[nowblock][nid-MinGID];
			dilatation[lid] = recvbuf[nowblock][i][j];
			
		}
	}
	int *neighborPtr = (int *)malloc(sizeof(int)*numOwnedPoints);
	/*hipMemcpy(force, param->force, (numOwnedPoints)*3*sizeof(double),hipMemcpyDeviceToHost);
  	for( i=0;i<numOwnedPoints*3;i++){
	//if(!isfinite(force1[i]))
	//	printf(\n");
		if(fabs(force[i]- oriforce[i])/fabs(oriforce[i])>1.0e-7 || !isfinite(oriforce[i])){
			printf("%d : Force Wrong! %d: %e, %e\n",myrank, i, force[i], oriforce[i]);
			//cout<<myrank<<" : Force Wrong! "<<i<<":"<<force[i]<<","<<oriforce[i]<<endl;
			break;
		}
 	 }
  	if(i == numOwnedPoints*3)
		printf("%d : Force Right\n",myrank);*/
		//cout<<myrank<<" : Force Right!"<<endl;
	//hipMemcpy(neighborPtr, param->neighborPtr, (numOwnedPoints)*sizeof(int ),hipMemcpyDeviceToHost);
	//printf("Thanks for using the GPU version!!!! %p,%d\n",param->force,globalnum);
	//printf("myrank %d: %d in dilatation[%d] = %e\n", myrank ,35250, LIDList[nowblock][35250-MinGID], (param->cellvolume)[36000]);
	//param->numOwnedpoints = numOwnedPoints;
	hipLaunchKernelGGL(ForceKernel, dim3(nblocks),dim3(BLOCKSIZE),0,0,param->x, param->y, param->weightvolume, param->cellvolume, param->dilatation, param->mybondDamage, param->force, param->neiborlist, numOwnedPoints, bulkModulus,shearModulus,horizon,param->neighborPtr);
	//ForceTest(x, y, weightvolume, cellvolume, dilatation, bondDamage, force, neighborhoodList, numOwnedPoints, bulkModulus,shearModulus,horizon,neighborPtr);
	hipDeviceSynchronize();
	hipMemcpy(force, param->force, (numOwnedPoints)*3*sizeof(double),hipMemcpyDeviceToHost);
	//printf("Thanks for using the GPU version!!!! %p,%d\n",param->force,globalnum);
	//const int* nPtr = neighborhoodList;
	//int neighbor = *nPtr;
	//nPtr++;
	//for(int i =0; i<neighbor; i++, nPtr++)
	//	printf("%e ",dilatation[*nPtr]);
	//printf("\n");
	
        //Hip
	
}

